package com.test.classes;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Scanner;
import java.util.Set;

public class CloseMatchingAddress {

	public static void main(String[] args) {
		String nAdd = "";

		Scanner sc = new Scanner(System.in);
		System.out.println("Please enter no. of M addresses");
		int m = sc.nextInt();
		String[] mAddress = new String[m];

		sc.nextLine();
		for (int i = 0; i < m; i++) {
			String add = sc.nextLine();
			mAddress[i] = add;
		}
		System.out.println("Please enter New Address");
		nAdd = sc.nextLine();

		List<Address> mAddressSet = getMAddressSet(mAddress);
		int maxScoreIndex = getBestMatch(nAdd, mAddressSet);
		System.out.println("Output is -- " + mAddress[maxScoreIndex]);
	}

	private static int getBestMatch(String nAdd, List<Address> mAddressSet) {
		Address nAddress = getAddressObj(nAdd.split(","));
		int score = 0;
		int maxScoreIndex = 0;
		int maxScore = -1;
		int index = 0;
		for (Address ad : mAddressSet) {
//			System.out.println(nAddress.toString());
//			System.out.println(ad.toString());
			if (nAddress.toString().equals(ad.toString())) {
				return index;
			} else {
				score = getScore(ad,nAddress);
			}
			
			if(score>maxScore) {
				maxScoreIndex = index;
				maxScore = score;
			}
			index++;
		}
		return maxScoreIndex;
	}

	private static int getScore(Address ad, Address nAddress) {
		int score = 0;
		if  ((ad.getCity() == null && nAddress.getCity() == null) || (ad.getCity() != null && ad.getCity().equals(nAddress.getCity()))) {
			score += 10000;
		}
		
		if ((ad.getArea() == null && nAddress.getArea() == null) || (ad.getArea() != null && ad.getArea().equals(nAddress.getArea()))) {
			score +=1000 
		}
		return score;
	}

	private static List<Address> getMAddressSet(String[] mAddress) {

		List<Address> mAddressSet = new ArrayList<Address>();
		String[] addSplits = null;
		for (int i = 0; i < mAddress.length; i++) {
			String add = mAddress[i];
			addSplits = add.split(",");
			Address address = getAddressObj(addSplits);
			mAddressSet.add(address);
		}
		return mAddressSet;

	}

	private static Address getAddressObj(String[] addSplits) {
		Address address = new Address();
		for (int j = 0; j < addSplits.length; j++) {
			if (isNumeric(addSplits[j])) {
				address.setPlotNo(addSplits[j].trim());
			} else if (addSplits[j].contains("Plot")) {
				address.setPlotNo(addSplits[j].split("Plot")[1].trim());
			} else if (addSplits[j].contains("Sector")) {
				address.setSector(addSplits[j].split("Sector")[1].trim());
			} else if (addSplits[j].contains("/")) {
				address.setSector(addSplits[j].split("/")[0].trim());
				address.setPlotNo(addSplits[j].split("/")[1].trim());
			}
		}
		if (isLastSecondIsNotArea(addSplits[addSplits.length - 2].trim())) {
			address.setArea(addSplits[addSplits.length - 1].trim());
		} else {
			address.setArea(addSplits[addSplits.length - 2].trim());
			address.setCity(addSplits[addSplits.length - 1].trim());
		}
		return address;
	}

	private static boolean isLastSecondIsNotArea(String input) {
		if (isNumeric(input) || input.contains("Plot") || input.contains("Sector") || input.contains("/")) {
			return true;
		}
		return false;
	}

	public static boolean isNumeric(String s) {
		return s != null && s.matches("[-+]?\\d*\\.?\\d+");
	}

}
